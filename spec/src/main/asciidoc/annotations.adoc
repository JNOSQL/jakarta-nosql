// Copyright (c) 2019-2020 Otavio Santana, Leonardo de Moura Rocha Lima and others
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

=== Models Annotation

As mentioned previously, the Mapping API has annotations that make the Java developer's life easier; these annotations have two categories:

* Annotation Models
* Qualifier annotation

==== Annotation Models

The annotation model converts the entity model into the entity on communication, the communication entity:


* Entity
* Column
* MappedSuperclass
* Id
* Embeddable
* Convert


Jakarta NoSQL Mapping does not require getter and setter methods to fields. However, the Entity class must have a non-private constructor with no parameters.

===== @Entity

This annotation maps the class to Eclipse Jakarta NoSQL. It has a single value attribute. This attribute specifies the column family name, or the document collection name, etc. The default value is the simple name of the class. For example, given the `org.jakarta.nosql.demo.Person` class, the default name will be `Person`.

[source,java]
----
@Entity
public class Person {
}
----

[source,java]
----
@Entity("ThePerson")
public class Person {
}
----

An entity that is a field be will incorporated as a sub-entity. For example, in a Document, the entity field will be converted to a subdocument.


[source,java]
----
@Entity
public class Person {

    @Id
    private Long id;

    @Column
    private String name;

    @Column
    private Address address;

}


@Entity
public class Address {

    @Column
    private String street;

    @Column
    private String city;

}
----


[source,json]
----
{
   "_id":10,
   "name":"Ada Lovelave",
   "address":{
      "city":"São Paulo",
      "street":"Av Nove de Julho"
   }
}
----
===== @Column

This annotation is to define which fields on an Entity will be persisted. It also has a unique attribute name to specify that name on Database, and the default value is the field name.


[source,java]
----
@Entity
public class Person {
    @Column
    private String nickname;

    @Column("personName")
    private String name;

    @Column
    private List<String> phones;

    //ignored
    private String address;
}
----

===== @MappedSuperclass


If this annotation is on the parent class, it will persist its information as well. So, beyond the son class, it will store any field that is in Parent class with Column annotation.


[source,java]
----
@Entity
public class Dog extends Animal {

    @Column
    private String name;

}

@MappedSuperclass
public class Animal {

    @Column
    private String race;

    @Column
    private Integer age;

}
----

On this sample above, when saving a Dog instance, it saves the Animal case too; explicitly, will save the field's `name`, `race`, and `age`.

===== @Id

It shows which attribute is the id, or the key in key-value types. Thus, the value will be the remaining information. It has an attribute as the Column to define the native name. However, the default value of this annotation is `_id`. The way of storing the class will depend on the database driver.


[source,java]
----
@Entity
public class User implements Serializable {

    @Id
    private String userName;

    @Column
    private String name;

    @Column
    private List<String> phones;
}
----


===== @Embeddable

Defines a class whose instances are stored as an intrinsic part of an owning entity and share the identity of that object. The behaviour is similar to `@MappedSuperclass`, but this is used on composition instead of inheritance.

[source,java]
----
@Entity
public class Book {

    @Column
    private String title;

    @Column
    private Author author;
}

@Embeddable
public class Author {

    @Column
    private String author;

    @Column
    private Integer age;
}

In this example, there is a single Instance in the database with columns `title`, `author` and `age`.
----

===== @Convert

This annotation allows value convertions when mapping the value that came from the Communication API. This is useful for cases such as to cipher a field (String to String conversion), or to convert to a custom type. The Converter annotation has a single, mandatory parameter: a Class that inherits from AttributeConverter that will be used to perform the convertion. The example below shows how to create a converter to a custom Money class.

[source,java]
----
@Entity
public class Employee {
    
    @Column
    private String name;

    @Column
    private Job job;

    @Column("money")
    @Convert(MoneyConverter.class)
    private MonetaryAmmount salary;
}

public class MoneyConverter implements AttributeConverter<MonetaryAmmount, String> {
    
    @Override
    public String convertToDatabaseColumn(MonetaryAmmount appValue) {
        return appValue.toString();
    }
    
    @Override
    public MonetaryAmmount convertToEntityAttribute(String dbValue) {
        return MonetaryAmmount.parse(dbValue);
    }
}

public class MonetaryAmmount {
    private final String currency;

    private final BigDecimal value;

    public String toString() {
        //specific implementation
    }

    public static MonetaryAmmount parse(String string) {
        //specific implementation
    }

}
----

===== Collections

The Mapping layer has support for `java.util.Collection` to both simple elements such as `String`, `Integer`, that will send to the communication API the exact value and class that has fields inside, once the class has either `Entity` or `Embedded` annotation; otherwise, will post as the first scenario, such as String or any amount without converter process.

The following collections are supported:

* `java.util.Deque`
* `java.util.Queue`
* `java.util.List`
* `java.util.Iterable`
* `java.util.NavigableSet`
* `java.util.SortedSet`
* `java.util.Collection`


[source,java]
----
@Entity
public class Person {

    @Id
    private Long id;

    @Column
    private String name;

    @Column
    private List<String> phones;

    @Column
    private List<Address> addresses;
}

@Embeddable
public class Address {

    @Column
    private String street;

    @Column
    private String city;

}
----

The above classes are mapped to:

[source,json]
----
{
   "_id":10,
   "addresses":[
      {
         "city":"São Paulo",
         "street":"Av Nove de Julho"
      },
      {
         "city":"Salvador",
         "street":"Rua Engenheiro Jose Anasoh"
      }
   ],
   "name":"Name",
   "phones":[
      "234",
      "432"
   ]
}
----
==== @Database

This annotation allows programmers to specialize `@Inject` annotations to choose which specific resource should be injected.

For example, when working with multiple DocumentRepositories, the following is ambiguous:

[source,java]
----
@Inject
private DocumentRepository repositoryA;

@Inject
private DocumentRepository repositoryB;
----

`@Database` has two attributes to help specify what resource should be injected:

* *DatabaseType*: The database type (key-value, document, column, graph);
* *provider*: The provider's database name

Applying the annotation to the example above, the result is:

[source,java]
----
@Inject
@Database(value = DatabaseType.DOCUMENT, provider = “databaseA”)
private DocumentRepository repositoryA;

@Inject
@Database(value = DatabaseType.DOCUMENT, provider = “databaseB”)
private DocumentRepository repositoryB;
----

A producer method annotaded with the same `@Database` values must exist as well.